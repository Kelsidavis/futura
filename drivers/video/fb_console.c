// SPDX-License-Identifier: MPL-2.0
/*
 * fb_console.c - Framebuffer-based console driver
 *
 * Provides text output directly to framebuffer memory without requiring
 * a serial console. Useful for embedded systems (RPi5) and headless QEMU.
 *
 * Character rendering: Simple 8x8 pixel monospace characters
 * Scrolling: Vertical scrolling when reaching bottom
 */

#include <kernel/fb_console.h>
#include <kernel/fb.h>
#include <platform/platform.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

/* ============================================================
 *   Simple 8x8 Bitmap Font
 * ============================================================ */

/* ASCII characters 32-126 as 8x8 pixel bitmaps */
static const uint8_t g_font_8x8[95][8] = {
    /* 32: space */ {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    /* 33: ! */ {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},
    /* 34: " */ {0x66, 0x66, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00},
    /* 35: # */ {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},
    /* 36: $ */ {0x0C, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00},
    /* 37: % */ {0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00},
    /* 38: & */ {0x3C, 0x66, 0x3C, 0x38, 0x67, 0x66, 0x3F, 0x00},
    /* 39: ' */ {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
    /* 40: ( */ {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},
    /* 41: ) */ {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},
    /* 42: * */ {0x00, 0x18, 0x7E, 0x3C, 0x7E, 0x18, 0x00, 0x00},
    /* 43: + */ {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},
    /* 44: , */ {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},
    /* 45: - */ {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},
    /* 46: . */ {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
    /* 47: / */ {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00},
    /* 48: 0 */ {0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00},
    /* 49: 1 */ {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00},
    /* 50: 2 */ {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00},
    /* 51: 3 */ {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00},
    /* 52: 4 */ {0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00},
    /* 53: 5 */ {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00},
    /* 54: 6 */ {0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00},
    /* 55: 7 */ {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x00},
    /* 56: 8 */ {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00},
    /* 57: 9 */ {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00},
    /* 58: : */ {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00},
    /* 59: ; */ {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00},
    /* 60: < */ {0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00},
    /* 61: = */ {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00},
    /* 62: > */ {0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00},
    /* 63: ? */ {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00},
    /* 64: @ */ {0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00},
    /* 65: A */ {0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00},
    /* 66: B */ {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00},
    /* 67: C */ {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00},
    /* 68: D */ {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00},
    /* 69: E */ {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00},
    /* 70: F */ {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00},
    /* 71: G */ {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00},
    /* 72: H */ {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00},
    /* 73: I */ {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00},
    /* 74: J */ {0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00},
    /* 75: K */ {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00},
    /* 76: L */ {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00},
    /* 77: M */ {0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00},
    /* 78: N */ {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00},
    /* 79: O */ {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},
    /* 80: P */ {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00},
    /* 81: Q */ {0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00},
    /* 82: R */ {0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00},
    /* 83: S */ {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00},
    /* 84: T */ {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
    /* 85: U */ {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},
    /* 86: V */ {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00},
    /* 87: W */ {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},
    /* 88: X */ {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00},
    /* 89: Y */ {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00},
    /* 90: Z */ {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00},
    /* 91: [ */ {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00},
    /* 92: \ */ {0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00},
    /* 93: ] */ {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00},
    /* 94: ^ */ {0x10, 0x38, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00},
    /* 95: _ */ {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
    /* 96: ` */ {0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    /* 97: a */ {0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00},
    /* 98: b */ {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00},
    /* 99: c */ {0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00},
    /* 100: d */ {0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00},
    /* 101: e */ {0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00},
    /* 102: f */ {0x1C, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00},
    /* 103: g */ {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C},
    /* 104: h */ {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00},
    /* 105: i */ {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00},
    /* 106: j */ {0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38},
    /* 107: k */ {0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00},
    /* 108: l */ {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},
    /* 109: m */ {0x00, 0x00, 0x6C, 0x7F, 0x6B, 0x6B, 0x6B, 0x00},
    /* 110: n */ {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00},
    /* 111: o */ {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00},
    /* 112: p */ {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60},
    /* 113: q */ {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06},
    /* 114: r */ {0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00},
    /* 115: s */ {0x00, 0x00, 0x3C, 0x60, 0x3C, 0x06, 0x3C, 0x00},
    /* 116: t */ {0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00},
    /* 117: u */ {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00},
    /* 118: v */ {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00},
    /* 119: w */ {0x00, 0x00, 0x6B, 0x6B, 0x6B, 0x7F, 0x6B, 0x00},
    /* 120: x */ {0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00},
    /* 121: y */ {0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C},
    /* 122: z */ {0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00},
    /* 123: { */ {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00},
    /* 124: | */ {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
    /* 125: } */ {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00},
    /* 126: ~ */ {0x7C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

/* ============================================================
 *   Framebuffer Console State
 * ============================================================ */

struct fb_console_state {
    volatile uint8_t *fb_mem;        /* Framebuffer memory pointer */
    uint32_t width;                  /* Framebuffer width in pixels */
    uint32_t height;                 /* Framebuffer height in pixels */
    uint32_t pitch;                  /* Bytes per scanline */
    uint32_t bpp;                    /* Bits per pixel (32 for RGBA) */
    int cursor_x;                    /* Current cursor X (in characters) */
    int cursor_y;                    /* Current cursor Y (in characters) */
    int char_width;                  /* Character width in pixels (8) */
    int char_height;                 /* Character height in pixels (8) */
    int cols;                        /* Number of columns */
    int rows;                        /* Number of rows */
    int initialized;                 /* Has been initialized */
};

static struct fb_console_state g_fb_console = {0};

/* ============================================================
 *   Helper Functions
 * ============================================================ */

static inline uint32_t make_color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    return ((uint32_t)a << 24) | ((uint32_t)r << 16) | ((uint32_t)g << 8) | (uint32_t)b;
}

static void fb_console_draw_pixel(int x, int y, uint32_t color) {
    struct fb_console_state *cons = &g_fb_console;

    if (x < 0 || x >= (int)cons->width || y < 0 || y >= (int)cons->height) {
        return;
    }

    uint8_t *fb = (uint8_t *)cons->fb_mem;
    uint32_t offset = (y * cons->pitch) + (x * 4);
    if (cons->bpp == 32) {
        *(volatile uint32_t *)(fb + offset) = color;
    } else if (cons->bpp == 24) {
        fb[offset + 0] = (color >> 16) & 0xFF;
        fb[offset + 1] = (color >> 8) & 0xFF;
        fb[offset + 2] = color & 0xFF;
    }
}

static void fb_console_draw_char(int char_x, int char_y, char c, uint32_t fg_color, uint32_t bg_color) {
    struct fb_console_state *cons = &g_fb_console;

    if (c < 32 || c > 126) {
        c = '?';
    }

    const uint8_t *glyph = g_font_8x8[c - 32];
    int pixel_x = char_x * cons->char_width;
    int pixel_y = char_y * cons->char_height;

    for (int row = 0; row < cons->char_height; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < cons->char_width; col++) {
            uint32_t color = (bits & (1 << (7 - col))) ? fg_color : bg_color;
            fb_console_draw_pixel(pixel_x + col, pixel_y + row, color);
        }
    }
}

static void fb_console_scroll(void) {
    struct fb_console_state *cons = &g_fb_console;

    uint8_t *fb = (uint8_t *)cons->fb_mem;

    /* Move all lines up by one character height */
    for (int y = 0; y < (cons->rows - 1) * cons->char_height; y++) {
        uint32_t src_offset = (y + cons->char_height) * cons->pitch;
        uint32_t dst_offset = y * cons->pitch;
        for (uint32_t x = 0; x < cons->pitch; x++) {
            fb[dst_offset + x] = fb[src_offset + x];
        }
    }

    /* Clear the bottom line */
    uint32_t bottom_offset = (cons->rows - 1) * cons->char_height * cons->pitch;
    uint32_t bg_color = make_color(0, 0, 0, 255);
    uint32_t *fb_word = (uint32_t *)(fb + bottom_offset);
    for (uint32_t i = 0; i < cons->pitch / 4; i++) {
        fb_word[i] = bg_color;
    }
}

/* ============================================================
 *   Public API
 * ============================================================ */

int fb_console_init(void) {
    struct fb_console_state *cons = &g_fb_console;

    if (cons->initialized) {
        return 0;
    }

    /* Get framebuffer from global framebuffer info */
    extern int fb_get_info(struct fut_fb_hwinfo *out);
    struct fut_fb_hwinfo hw_info = {0};

    if (!fb_get_info(&hw_info)) {
        fut_printf("[FB_CONSOLE] No framebuffer available\n");
        return -1;
    }

    if (hw_info.info.width == 0 || hw_info.info.height == 0) {
        fut_printf("[FB_CONSOLE] Invalid framebuffer dimensions\n");
        return -1;
    }

    cons->width = hw_info.info.width;
    cons->height = hw_info.info.height;
    cons->pitch = hw_info.info.pitch;
    cons->bpp = hw_info.info.bpp;
    cons->fb_mem = (volatile uint8_t *)hw_info.phys;

    cons->char_width = 8;
    cons->char_height = 8;
    cons->cols = cons->width / cons->char_width;
    cons->rows = cons->height / cons->char_height;
    cons->cursor_x = 0;
    cons->cursor_y = 0;
    cons->initialized = 1;

    fut_printf("[FB_CONSOLE] Initialized: %ux%u, %u cols x %u rows\n",
               cons->width, cons->height, cons->cols, cons->rows);

    fb_console_clear();
    return 0;
}

void fb_console_clear(void) {
    struct fb_console_state *cons = &g_fb_console;

    if (!cons->initialized) {
        return;
    }

    uint8_t *fb = (uint8_t *)cons->fb_mem;
    uint32_t bg_color = make_color(0, 0, 0, 255);

    if (cons->bpp == 32) {
        uint32_t *fb_word = (uint32_t *)fb;
        for (uint32_t i = 0; i < (cons->width * cons->height); i++) {
            fb_word[i] = bg_color;
        }
    } else if (cons->bpp == 24) {
        for (uint32_t i = 0; i < cons->pitch * cons->height; i++) {
            fb[i] = 0;
        }
    }

    cons->cursor_x = 0;
    cons->cursor_y = 0;
}

void fb_console_putc(char c) {
    struct fb_console_state *cons = &g_fb_console;

    if (!cons->initialized) {
        return;
    }

    uint32_t fg_color = make_color(255, 255, 255, 255);
    uint32_t bg_color = make_color(0, 0, 0, 255);

    if (c == '\n') {
        cons->cursor_x = 0;
        cons->cursor_y++;
        if (cons->cursor_y >= cons->rows) {
            fb_console_scroll();
            cons->cursor_y = cons->rows - 1;
        }
    } else if (c == '\r') {
        cons->cursor_x = 0;
    } else if (c == '\t') {
        cons->cursor_x += 4;
        if (cons->cursor_x >= cons->cols) {
            cons->cursor_x = 0;
            cons->cursor_y++;
            if (cons->cursor_y >= cons->rows) {
                fb_console_scroll();
                cons->cursor_y = cons->rows - 1;
            }
        }
    } else {
        fb_console_draw_char(cons->cursor_x, cons->cursor_y, c, fg_color, bg_color);
        cons->cursor_x++;
        if (cons->cursor_x >= cons->cols) {
            cons->cursor_x = 0;
            cons->cursor_y++;
            if (cons->cursor_y >= cons->rows) {
                fb_console_scroll();
                cons->cursor_y = cons->rows - 1;
            }
        }
    }
}

void fb_console_write(const char *str, size_t len) {
    for (size_t i = 0; i < len; i++) {
        fb_console_putc(str[i]);
    }
}

void fb_console_putc_at(int x, int y, char c) {
    struct fb_console_state *cons = &g_fb_console;

    if (!cons->initialized || x < 0 || x >= cons->cols || y < 0 || y >= cons->rows) {
        return;
    }

    uint32_t fg_color = make_color(255, 255, 255, 255);
    uint32_t bg_color = make_color(0, 0, 0, 255);
    fb_console_draw_char(x, y, c, fg_color, bg_color);
}

void fb_console_get_dimensions(int *width, int *height) {
    struct fb_console_state *cons = &g_fb_console;

    if (width) {
        *width = cons->initialized ? cons->cols : 0;
    }
    if (height) {
        *height = cons->initialized ? cons->rows : 0;
    }
}
